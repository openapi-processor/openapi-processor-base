/*
 * Copyright 2020 https://github.com/openapi-processor/openapi-processor-base
 * PDX-License-Identifier: Apache-2.0
 */

package io.openapiprocessor.test

import java.nio.file.FileSystem
import java.nio.file.Files
import java.nio.file.Path

import static io.openapiprocessor.test.TestSetRunner.ResolveType.PATH_DIFF
import static io.openapiprocessor.test.TestSetRunner.ResolveType.PATH_GENERATED

/**
 * used to execute test sets.
 *
 * "expected" represents the files from the "outputs" folder of the test case
 * "generated" represents the files generated by the processor
 */
class TestSetRunner {

    enum ResolveType {
        PATH_GENERATED, PATH_DIFF
    }

    Test test
    TestSet testSet
    FileSupport files
    Class testResourcesBase

    TestSetRunner(Test test, TestSet testSet, FileSupport files, private Class testResourcesBase) {
        this.test = test
        this.testSet = testSet
        this.files = files

        this.testResourcesBase = testResourcesBase
    }

    /**
     * runs test set on the native file system
     *
     * @param targetFolder temp folder
     * @return true on success, false on failure, ie. if there were any differences
     */

    boolean runOnNativeFileSystem (File targetFolder) {
        test.init()

        def options = [
            parser: test.parser,
            apiPath: test.apiPath.toString(),
            targetDir: test.targetDir.toString()
        ]

        def mapping = test.mapping
        options.mapping = mapping.yaml

        when:
        testSet.processor.run (options)

        then:
        def packageName = mapping.packageName
        def testProcessor = testSet.processor as OpenApiProcessorTest
        def sourceRoot = testProcessor.sourceRoot
        def resourceRoot = testProcessor.resourceRoot

        def sourcePath = "/tests/${testSet.name}"
        def expectedPath = "${sourcePath}/${testSet.expected}"
        def expectedFiles = files.getExpectedFiles (sourcePath, testSet.expected)
        def expectedCheck = stripBase(expectedFiles, sourceRoot, resourceRoot)

        def generatedPath = Path.of (targetFolder.absolutePath)
        def generatedSourcePath = getGeneratedSourcePath(targetFolder, sourceRoot, packageName)
        def generatedResourcePath = getGeneratedResourcePath(targetFolder, resourceRoot)

        Set<String> generatedSourceFiles = files.getGeneratedFiles (generatedSourcePath)
        if (resourceRoot != null) {
            Set<String> generatedResourceFiles = files.getGeneratedFiles (generatedResourcePath)
            generatedSourceFiles.addAll(generatedResourceFiles)
        }

        def generatedFilesCheck = filterGeneratedFiles(
                expectedCheck,
                generatedSourceFiles, [
                "support/Generated.java",
                "validation/Values.java",
                "validation/ValueValidator.java"
        ] as Set<String>)

        def expectedFileKeys = expectedCheck.keySet()
        def generatedFileKeys = generatedFilesCheck.keySet()
        def expectedFileNames = resolveFileNames(expectedFileKeys, PATH_GENERATED)
        assert expectedFileNames == generatedFileKeys

        // compare expected files with the generated files
        def success = true
        expectedCheck.each {
            def expectedFilePath = it.key
            if (it.value != null) {
                expectedFilePath = "${it.value}/${it.key}"
            }
            expectedFilePath = "${expectedPath}/${resolveFileName(expectedFilePath, PATH_DIFF)}"


            def generatedFilePath = generatedPath
            if (it.value != null) {
                generatedFilePath = generatedFilePath.resolve(it.value)
            }
            if (it.value == sourceRoot) {
                generatedFilePath = generatedFilePath.resolve(packageName)
            }
            generatedFilePath = generatedFilePath.resolve(resolveFileName(it.key, PATH_GENERATED))

            success &= !files.printUnifiedDiff (expectedFilePath, generatedFilePath)
        }

        success
    }

    /**
     * runs test set on the given file system
     *
     * @param fs the file system
     * @return true on success, false on failure, ie. if there were any differences
     */
    boolean runOnCustomFileSystem (FileSystem fs) {
        test.init()

        def options = [
            parser: test.parser,
            apiPath: test.apiPath.toString(),
            targetDir: test.targetDir.toString()
        ]

        def mapping = test.mapping
        options.mapping = mapping.yaml

        when:
        testSet.processor.run (options)

        then:
        def packageName = mapping.packageName
        def testProcessor = testSet.processor as OpenApiProcessorTest
        def sourceRoot = testProcessor.sourceRoot
        def resourceRoot = testProcessor.resourceRoot

        Path root = fs.getPath ("source")
        Path target = fs.getPath ('target')
        def path = "/tests/${testSet.name}"

        def expectedPath = root.resolve(testSet.expected)
        def expectedFiles = files.getExpectedFiles (path, testSet.expected)
        def expectedCheck = stripBase(expectedFiles, sourceRoot, resourceRoot)

        def generatedPath = target
        def generatedSourcePath = getGeneratedSourcePath(target, sourceRoot, packageName)
        def generatedResourcePath = getGeneratedResourcePath(target, resourceRoot)

        Set<String> generatedSourceFiles = files.getGeneratedFiles (generatedSourcePath)
        if (resourceRoot != null) {
            Set<String> generatedResourceFiles = files.getGeneratedFiles (generatedResourcePath)
            generatedSourceFiles.addAll(generatedResourceFiles)
        }

        def generatedFilesCheck = filterGeneratedFiles(
                expectedCheck,
                generatedSourceFiles, [
                "support/Generated.java",
                "validation/Values.java",
                "validation/ValueValidator.java"
        ] as Set<String>)

        def expectedFileKeys = expectedCheck.keySet()
        def generatedFileKeys = generatedFilesCheck.keySet()
        def expectedFileNames = resolveFileNames(expectedFileKeys, PATH_GENERATED)
        assert expectedFileNames == generatedFileKeys

        def success = true
        expectedCheck.each {
            def expectedFilePath = it.key
            if (it.value != null) {
                expectedFilePath = "${it.value}/${it.key}"
            }
            expectedFilePath = fs.getPath("${expectedPath}/${resolveFileName(expectedFilePath, PATH_DIFF)}")


            def generatedFilePath = generatedPath
            if (it.value != null) {
                generatedFilePath = generatedFilePath.resolve(it.value)
            }
            if (it.value == sourceRoot) {
                generatedFilePath = generatedFilePath.resolve(packageName)
            }
            generatedFilePath = generatedFilePath.resolve(resolveFileName(it.key, PATH_GENERATED))

            success &= !files.printUnifiedDiffFs (expectedFilePath, generatedFilePath)
        }

        success
    }

    private static Map<String, String> stripBase(SortedSet<String> files, String source, String resource) {
        def result = new TreeMap<String, String>()

        files.each {
            if (source != null && it.startsWith(source)) {
                result[it.substring(source.length() + 1)] = source

            } else if (resource != null && it.startsWith(resource)) {
                result[it.substring(resource.length() + 1)] = resource

            } else {
                result[it] = null
            }
        }

        return result
    }

    private static Map<String, String> filterGeneratedFiles(
            Map<String, String> expectedFiles,
            Set<String> generatedFiles,
            Set<String> unexpectedFiles
    ) {
        def generated = new TreeMap<String, String>()
        generatedFiles.each {
            if (!expectedFiles.containsKey(it) && unexpectedFiles.contains(it)) {
                return
            }

            def value = expectedFiles.get(it)
            generated.put(it, value)
        }
        return generated
    }

    private static Set<String> filterUnexpectedFiles(
            Set<String> expectedFiles,
            Set<String> generatedFiles,
            Set<String> unexpectedFiles
    ) {
        def generated = new TreeSet<String>()
        generatedFiles.each {
            if (!expectedFiles.contains(it) && unexpectedFiles.contains(it)) {
                return
            }
            generated.add(it)
        }
        return generated as SortedSet<String>
    }

    private static Path getGeneratedSourcePath(File targetFolder, String source, String packageName) {
        def path = Path.of (targetFolder.absolutePath)
        if (source != null) {
            path = path.resolve(source)
        }
        return path.resolve (packageName)
    }

    private static Path getGeneratedSourcePath(Path target, String source, String packageName) {
        def path = target
        if (source != null) {
            path = path.resolve(source)
        }
        return path.resolve (packageName)
    }

    private static Path getGeneratedResourcePath(File targetFolder, String resource) {
        def path = Path.of (targetFolder.absolutePath)
        if (resource != null) {
            path = path.resolve(resource)
        }
        return path
    }

    private static Path getGeneratedResourcePath(Path target, String resource) {
        def path = target
        if (resource != null) {
            path = path.resolve(resource)
        }
        return path
    }

    private static SortedSet<String> addBase(SortedSet<String> files, String base) {
        if (base.isEmpty()) {
            return files
        }

        return files.each {
            return "${base}/it"
        }
    }

    InputStream getResource (String path) {
        testResourcesBase.getResourceAsStream (path)
    }

    private Set<String> resolveFileNames(Collection<String> paths, ResolveType type) {
        def result = new TreeSet<String> ()

        paths.each {
            result.add(resolveFileName(it, type))
        }

        result
    }

    private String resolveFileName(String path, ResolveType type) {
        def model = "unset"

        if (type == PATH_GENERATED) {
            model = 'model'

        } else if (type == PATH_DIFF) {
            model = 'model/default'

            if (testSet.modelType == 'record') {
                model = 'model/record'
            }
        }

        def result = path.replaceFirst("<model>", model)
        return result
    }

    private printFsTree(FileSystem fs) {
        Files.walk (fs.getPath("/"))
            .forEach {
                println "${it.toAbsolutePath()}"
            }
    }
}
