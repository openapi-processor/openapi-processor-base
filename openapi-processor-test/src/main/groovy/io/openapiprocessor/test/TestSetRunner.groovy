/*
 * Copyright 2020 https://github.com/openapi-processor/openapi-processor-base
 * PDX-License-Identifier: Apache-2.0
 */

package io.openapiprocessor.test

import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.PropertyNamingStrategies
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory

import java.nio.file.FileSystem
import java.nio.file.Files
import java.nio.file.Path

import static io.openapiprocessor.test.TestSetRunner.ResolveType.PATH_DIFF
import static io.openapiprocessor.test.TestSetRunner.ResolveType.PATH_GENERATED

/**
 * used to execute test sets.
 *
 * "expected" represents the files from the "outputs" folder of the test case
 * "generated" represents the files generated by the processor
 */
class TestSetRunner {

    enum ResolveType {
        PATH_GENERATED, PATH_DIFF
    }

    TestSet testSet
    FileSupport files
    Class testResourcesBase
    TestItemsReader itemReader

    TestSetRunner(TestSet testSet, FileSupport files, private Class testResourcesBase) {
        this.testSet = testSet
        this.files = files

        this.testResourcesBase = testResourcesBase
        this.itemReader = new TestItemsReader(this.testResourcesBase)
    }

    /**
     * runs test set on the native file system
     *
     * @param targetFolder temp folder
     * @return true on success, false on failure, ie. if there were any differences
     */
    boolean runOnNativeFileSystem (File targetFolder) {
        def options = [
            parser: testSet.parser,
            apiPath: "resource:/tests/${testSet.name}/inputs/${testSet.openapi}",
            targetDir: targetFolder.absolutePath
        ]

        def mappingYaml = getMappingX(getResource ("/tests/${testSet.name}/inputs/mapping.yaml"))
        def mapping = new Mapping(mappingYaml)
        mapping.setModelType(testSet.modelType)
        options.mapping = mapping.yaml

        when:
        testSet.processor.run (options)

        then:
        def packageName = mapping.packageName
        def testProcessor = testSet.processor as OpenApiProcessorTest
        def sourceRoot = testProcessor.sourceRoot
        def resourceRoot = testProcessor.resourceRoot

        def sourcePath = "/tests/${testSet.name}"
        def expectedPath = "${sourcePath}/${testSet.expected}"
        def expectedFiles = files.getExpectedFiles (sourcePath, testSet.expected)
        def expectedCheck = stripBase(expectedFiles, sourceRoot, resourceRoot)

        def generatedPath = Path.of (targetFolder.absolutePath)
        def generatedSourcePath = getGeneratedSourcePath(targetFolder, sourceRoot, packageName)
        def generatedResourcePath = getGeneratedResourcePath(targetFolder, resourceRoot)

        Set<String> generatedSourceFiles = files.getGeneratedFiles (generatedSourcePath)
        if (resourceRoot != null) {
            Set<String> generatedResourceFiles = files.getGeneratedFiles (generatedResourcePath)
            generatedSourceFiles.addAll(generatedResourceFiles)
        }

        def generatedFilesCheck = filterGeneratedFiles(
                expectedCheck,
                generatedSourceFiles, [
                "support/Generated.java",
                "validation/Values.java",
                "validation/ValueValidator.java"
        ] as Set<String>)

        def expectedFileKeys = expectedCheck.keySet()
        def generatedFileKeys = generatedFilesCheck.keySet()
        def expectedFileNames = resolveFileNames(expectedFileKeys, PATH_GENERATED)
        assert expectedFileNames == generatedFileKeys

        // compare expected files with the generated files
        def success = true
        expectedCheck.each {
            def expectedFilePath = it.key
            if (it.value != null) {
                expectedFilePath = "${it.value}/${it.key}"
            }
            expectedFilePath = "${expectedPath}/${resolveFileName(expectedFilePath, PATH_DIFF)}"


            def generatedFilePath = generatedPath
            if (it.value != null) {
                generatedFilePath = generatedFilePath.resolve(it.value)
            }
            if (it.value == sourceRoot) {
                generatedFilePath = generatedFilePath.resolve(packageName)
            }
            generatedFilePath = generatedFilePath.resolve(resolveFileName(it.key, PATH_GENERATED))

            success &= !files.printUnifiedDiff (expectedFilePath, generatedFilePath)
        }

        success
    }

    /**
     * runs test set on the given file system
     *
     * @param fs the file system
     * @return true on success, false on failure, ie. if there were any differences
     */
    boolean runOnCustomFileSystem (FileSystem fs) {
        Path root = Files.createDirectory (fs.getPath ("source"))

        def path = "/tests/${testSet.name}"
        files.copy (path, files.collectAbsoluteInputPaths (path), root)

        def outputs = files.collectAbsoluteOutputPaths (path)
        outputs = resolveFileNames(outputs, PATH_DIFF).asList()
        files.copy (path, outputs, root)

        Path api = root.resolve ("inputs/${testSet.openapi}")
        Path target = fs.getPath ('target')

        def options = [
            parser: testSet.parser,
            apiPath: api.toUri ().toURL ().toString (),
            targetDir: target.toUri ().toURL ().toString ()
        ]

        def mappingYaml = getMappingX(root.resolve ('inputs/mapping.yaml'))
        def mapping = new Mapping(mappingYaml)
        mapping.setModelType(testSet.modelType)
        options.mapping = mapping.yaml

        when:
        testSet.processor.run (options)

        then:
        def packageName = mapping.packageName
        def testProcessor = testSet.processor as OpenApiProcessorTest
        def sourceRoot = testProcessor.sourceRoot
        def resourceRoot = testProcessor.resourceRoot

        def expectedPath = root.resolve(testSet.expected)
        def expectedFiles = files.getExpectedFiles (path, testSet.expected)
        def expectedCheck = stripBase(expectedFiles, sourceRoot, resourceRoot)

        def generatedPath = target
        def generatedSourcePath = getGeneratedSourcePath(target, sourceRoot, packageName)
        def generatedResourcePath = getGeneratedResourcePath(target, resourceRoot)

        Set<String> generatedSourceFiles = files.getGeneratedFiles (generatedSourcePath)
        if (resourceRoot != null) {
            Set<String> generatedResourceFiles = files.getGeneratedFiles (generatedResourcePath)
            generatedSourceFiles.addAll(generatedResourceFiles)
        }

        def generatedFilesCheck = filterGeneratedFiles(
                expectedCheck,
                generatedSourceFiles, [
                "support/Generated.java",
                "validation/Values.java",
                "validation/ValueValidator.java"
        ] as Set<String>)

        def expectedFileKeys = expectedCheck.keySet()
        def generatedFileKeys = generatedFilesCheck.keySet()
        def expectedFileNames = resolveFileNames(expectedFileKeys, PATH_GENERATED)
        assert expectedFileNames == generatedFileKeys

        def success = true
        expectedCheck.each {
            def expectedFilePath = it.key
            if (it.value != null) {
                expectedFilePath = "${it.value}/${it.key}"
            }
            expectedFilePath = fs.getPath("${expectedPath}/${resolveFileName(expectedFilePath, PATH_DIFF)}")


            def generatedFilePath = generatedPath
            if (it.value != null) {
                generatedFilePath = generatedFilePath.resolve(it.value)
            }
            if (it.value == sourceRoot) {
                generatedFilePath = generatedFilePath.resolve(packageName)
            }
            generatedFilePath = generatedFilePath.resolve(resolveFileName(it.key, PATH_GENERATED))

            success &= !files.printUnifiedDiffFs (expectedFilePath, generatedFilePath)
        }

        success
    }

    private static Map<String, String> stripBase(SortedSet<String> files, String source, String resource) {
        def result = new TreeMap<String, String>()

        files.each {
            if (source != null && it.startsWith(source)) {
                result[it.substring(source.length() + 1)] = source

            } else if (resource != null && it.startsWith(resource)) {
                result[it.substring(resource.length() + 1)] = resource

            } else {
                result[it] = null
            }
        }

        return result
    }

    private static Map<String, String> filterGeneratedFiles(
            Map<String, String> expectedFiles,
            Set<String> generatedFiles,
            Set<String> unexpectedFiles
    ) {
        def generated = new TreeMap<String, String>()
        generatedFiles.each {
            if (!expectedFiles.containsKey(it) && unexpectedFiles.contains(it)) {
                return
            }

            def value = expectedFiles.get(it)
            generated.put(it, value)
        }
        return generated
    }

    private static Set<String> filterUnexpectedFiles(
            Set<String> expectedFiles,
            Set<String> generatedFiles,
            Set<String> unexpectedFiles
    ) {
        def generated = new TreeSet<String>()
        generatedFiles.each {
            if (!expectedFiles.contains(it) && unexpectedFiles.contains(it)) {
                return
            }
            generated.add(it)
        }
        return generated as SortedSet<String>
    }

    private static Path getGeneratedSourcePath(File targetFolder, String source, String packageName) {
        def path = Path.of (targetFolder.absolutePath)
        if (source != null) {
            path = path.resolve(source)
        }
        return path.resolve (packageName)
    }

    private static Path getGeneratedSourcePath(Path target, String source, String packageName) {
        def path = target
        if (source != null) {
            path = path.resolve(source)
        }
        return path.resolve (packageName)
    }

    private static Path getGeneratedResourcePath(File targetFolder, String resource) {
        def path = Path.of (targetFolder.absolutePath)
        if (resource != null) {
            path = path.resolve(resource)
        }
        return path
    }

    private static Path getGeneratedResourcePath(Path target, String resource) {
        def path = target
        if (resource != null) {
            path = path.resolve(resource)
        }
        return path
    }

    private static SortedSet<String> addBase(SortedSet<String> files, String base) {
        if (base.isEmpty()) {
            return files
        }

        return files.each {
            return "${base}/it"
        }
    }

    private String getMappingOrDefault(String mappingYaml) {
        return mappingYaml ? mappingYaml : testSet.defaultOptions
    }

    private String getMappingX(InputStream mappingYaml) {
        return getMappingOrDefault(mappingYaml.text)
    }

    private String getMappingX(Path mappingYaml) {
        return getMappingOrDefault(Files.exists (mappingYaml) ? mappingYaml.toUri().toURL().text : (String)null)
    }

    InputStream getResource (String path) {
        testResourcesBase.getResourceAsStream (path)
    }

    private Set<String> resolveFileNames(Collection<String> paths, ResolveType type) {
        def result = new TreeSet<String> ()

        paths.each {
            result.add(resolveFileName(it, type))
        }

        result
    }

    private String resolveFileName(String path, ResolveType type) {
        def model = "unset"

        if (type == PATH_GENERATED) {
            model = 'model'

        } else if (type == PATH_DIFF) {
            model = 'model/default'

            if (testSet.modelType == 'record') {
                model = 'model/record'
            }
        }

        def result = path.replaceFirst("<model>", model)
        return result
    }

    private printFsTree(FileSystem fs) {
        Files.walk (fs.getPath("/"))
            .forEach {
                println "${it.toAbsolutePath()}"
            }
    }
}
