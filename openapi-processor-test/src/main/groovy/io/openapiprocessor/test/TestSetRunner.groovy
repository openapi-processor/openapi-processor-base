/*
 * Copyright 2020 https://github.com/openapi-processor/openapi-processor-base
 * PDX-License-Identifier: Apache-2.0
 */

package io.openapiprocessor.test

import java.nio.file.FileSystem
import java.nio.file.Files
import java.nio.file.Path

import static io.openapiprocessor.test.TestSetRunner.ResolveType.PATH_DIFF
import static io.openapiprocessor.test.TestSetRunner.ResolveType.PATH_GENERATED

/**
 * used to execute test sets.
 *
 * "expected" represents the files from the "outputs" folder of the test case
 * "generated" represents the files generated by the processor
 */
class TestSetRunner {

    enum ResolveType {
        PATH_GENERATED, PATH_DIFF
    }

    Test test
    TestSet testSet
    FileSupport files
    Class testResourcesBase

    TestSetRunner(Test test, TestSet testSet, FileSupport files, private Class testResourcesBase) {
        this.test = test
        this.testSet = testSet
        this.files = files

        this.testResourcesBase = testResourcesBase
    }

    /**
     * runs test set on the native file system
     *
     * @param targetFolder temp folder
     * @return true on success, false on failure, ie. if there were any differences
     */
    boolean runOnNativeFileSystem (File targetFolder) {
        test.init()

        def mapping = test.mapping
        def options = [
            parser: test.parser,
            apiPath: test.apiPath.toString(),
            targetDir: test.targetDir.toString(),
            mapping: mapping.yaml
        ]

        when:
        testSet.processor.run (options)

        then:
        def expectedFiles = test.expectedFiles
        def generatedFiles = getGeneratedFiles(expectedFiles)

        // check expected file names match generated file names
        def expectedFileKeys = expectedFiles.keySet()
        def generatedFileKeys = generatedFiles.keySet()
        def expectedFileNames = test.resolveModelTypeInTarget(expectedFileKeys)
        assert expectedFileNames == generatedFileKeys


        def packageName = mapping.packageName
        def testProcessor = testSet.processor as OpenApiProcessorTest
        def sourceRoot = testProcessor.sourceRoot
        def sourcePath = "/tests/${testSet.name}"
        def expectedPath = "${sourcePath}/${testSet.expected}"
        def generatedPath = Path.of (targetFolder.absolutePath)

        // compare expected files with the generated files
        def success = true
        expectedFiles.each {
            def expectedFilePath = it.key
            if (it.value != null) {
                expectedFilePath = "${it.value}/${it.key}"
            }

            expectedFilePath = "${expectedPath}/${resolveFileName(expectedFilePath, PATH_DIFF)}"


            def generatedFilePath = generatedPath
            if (it.value != null) {
                generatedFilePath = generatedFilePath.resolve(it.value)
            }
            if (it.value == sourceRoot) {
                generatedFilePath = generatedFilePath.resolve(packageName)
            }
            generatedFilePath = generatedFilePath.resolve(resolveFileName(it.key, PATH_GENERATED))

            success &= !files.printUnifiedDiff (expectedFilePath, generatedFilePath)
        }

        success
    }

    /**
     * runs test set on the given file system
     *
     * @param fs the file system
     * @return true on success, false on failure, ie. if there were any differences
     */
    boolean runOnCustomFileSystem (FileSystem fs) {
        test.init()

        def mapping = test.mapping
        def options = [
            parser: test.parser,
            apiPath: test.apiPath.toString(),
            targetDir: test.targetDir.toString(),
            mapping: mapping.yaml
        ]

        when:
        testSet.processor.run (options)

        then:
        def expectedFiles = test.expectedFiles
        def generatedFiles = getGeneratedFiles(expectedFiles)

        // check expected file names match generated file names
        def expectedFileKeys = expectedFiles.keySet()
        def generatedFileKeys = generatedFiles.keySet()
        def expectedFileNames = test.resolveModelTypeInTarget(expectedFileKeys)
        assert expectedFileNames == generatedFileKeys

        def packageName = mapping.packageName
        def testProcessor = testSet.processor as OpenApiProcessorTest
        def sourceRoot = testProcessor.sourceRoot
        Path root = fs.getPath ("source")
        Path target = fs.getPath ('target')
        def expectedPath = root.resolve(testSet.expected)
        def generatedPath = target

        def success = true
        expectedFiles.each {
            def expectedFilePath = it.key
            if (it.value != null) {
                expectedFilePath = "${it.value}/${it.key}"
            }

            expectedFilePath = fs.getPath("${expectedPath}/${resolveFileName(expectedFilePath, PATH_DIFF)}")


            def generatedFilePath = generatedPath
            if (it.value != null) {
                generatedFilePath = generatedFilePath.resolve(it.value)
            }
            if (it.value == sourceRoot) {
                generatedFilePath = generatedFilePath.resolve(packageName)
            }
            generatedFilePath = generatedFilePath.resolve(resolveFileName(it.key, PATH_GENERATED))

            success &= !files.printUnifiedDiffFs (expectedFilePath, generatedFilePath)
        }

        success
    }

    private Map<String, String> getGeneratedFiles(Map<String, String> expectedFiles) {
        def generatedFilesAll = test.generatedSourceFiles
        generatedFilesAll.addAll(test.generatedResourceFiles)

        def generatedFiles = filterUnexpectedFiles(
                expectedFiles,
                generatedFilesAll, [
                "support/Generated.java",
                "validation/Values.java",
                "validation/ValueValidator.java"
        ] as Set<String>)

        return generatedFiles
    }

    private static Map<String, String> filterUnexpectedFiles(
            Map<String, String> expectedFiles,
            Set<String> generatedFiles,
            Set<String> unexpectedFiles
    ) {
        def generated = new TreeMap<String, String>()
        generatedFiles.each {
            if (!expectedFiles.containsKey(it) && unexpectedFiles.contains(it)) {
                return
            }

            def value = expectedFiles.get(it)
            generated.put(it, value)
        }
        return generated
    }

    private static SortedSet<String> addBase(SortedSet<String> files, String base) {
        if (base.isEmpty()) {
            return files
        }

        return files.each {
            return "${base}/it"
        }
    }

    private Set<String> resolveFileNames(Collection<String> paths, ResolveType type) {
        def result = new TreeSet<String> ()

        paths.each {
            result.add(resolveFileName(it, type))
        }

        result
    }

    private String resolveFileName(String path, ResolveType type) {
        def model = "unset"

        if (type == PATH_GENERATED) {
            model = 'model'

        } else if (type == PATH_DIFF) {
            model = 'model/default'

            if (testSet.modelType == 'record') {
                model = 'model/record'
            }
        }

        def result = path.replaceFirst("<model>", model)
        return result
    }

    private printFsTree(FileSystem fs) {
        Files.walk (fs.getPath("/"))
            .forEach {
                println "${it.toAbsolutePath()}"
            }
    }
}
